{"version":3,"sources":["registerServiceWorker.js","components/SteamGames/SteamGamesExtraComponents.js","components/SteamGames/SteamGames.js","index.js"],"names":["isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","catch","error","PlayTime","_ref","playTimeMinutes","hours","Math","floor","minutes","hourText","minuteText","react_default","a","createElement","concat","PaginationButtons","_ref2","previousPageFn","nextPageFn","currentPage","totalPages","buttonsStatus","next","previous","className","onClick","data-total-pages","disabled","SteamGamesList","_ref3","gamesList","imgPath","imgType","map","_ref4","appid","name","playTime","playtime_forever","key","src","alt","width","height","SteamGamesExtraComponents_PlayTime","href","target","rel","FilterCheckboxes","_ref5","filterList","onChangeFn","Fragment","length","_ref6","index","start","end","isChecked","isUnplayed","filteredGameCount","startHours","round","endHours","labelText","htmlFor","id","type","onChange","data-index","checked","OrderRadioButtons","_ref7","value","FilterMenu","_ref8","collapsedData","totalGames","filteredGamesCount","playtimeFilters","toggleFiltersFn","updatePlaytimeFilterFn","updateSearchTextFn","updateOrderFn","buttonText","filterOptionsClass","role","aria-labelledby","SteamGamesExtraComponents_FilterCheckboxes","SteamGamesExtraComponents_OrderRadioButtons","SteamGames","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","nextPage","event","currentTarget","dataset","setState","prevState","newState","objectSpread","previousPage","updatePlaytimeFilter","updateSearchText","searchInput","searchFilter","updateOrder","orderType","toggleFilters","collapseFilters","playtimeRangeCheck","compareValue","valueInRange","gamesLoaded","filteredTotalGames","_this2","playtimeRangeValidationCheckers","filter","some","playtimeFilter","maxPlaytime","reduce","highest","current","minPlaytime","lowest","gamesPerPage","ceil","gamesFetchUrl","Promise","resolve","fetch","response","json","_ref4$response","gamesCount","game_count","games","_this3","_this3$props$hoursFil","hoursFilterRange","checkboxes","filterUnplayed","_this3$getMinAndMaxPl","getMinAndMaxPlaytime","playtimeRange","count","push","filterCountWithGameCounts","filterObject","newFilterObject","filteredArray","startIndex","finishIndex","slice","reorderedGamesList","toConsumableArray","sortCompareFunction","isAscending","b","sort","_ref9","_ref10","_ref11","_this$state","filteredGamesList","filterPlaytimes","filterSearchedGames","orderGamesList","game","toLowerCase","includes","isCollapsed","collapsedResults","filteredGameList","getFilteredGamesList","_this$getPaginationPa","getPaginationPages","tempCurrentPage","paginatedGamesList","getCurrentGamesForPage","collapsedFilterData","getJsxValuesForCollapsed","_this4","fetchGameState","generatePlaytimeFiltersToState","_this$state2","_this$props","steamImgPath","steamImgType","_this$getValuesForRen","getValuesForRender","SteamGamesExtraComponents_FilterMenu","SteamGamesExtraComponents_PaginationButtons","SteamGamesExtraComponents_SteamGamesList","Component","defaultProps","ReactDOM","render","components_SteamGames_SteamGames","document","getElementById","URL","process","origin","addEventListener","status","headers","get","indexOf","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.c7087021.chunk.js","sourcesContent":["// In production, we register a service worker to serve assets from local cache.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\r\n// cached resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\r\n// This link also includes instructions on opting out of this behavior.\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport default function register() {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Lets check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not local host. Just register service worker\r\n        registerValidSW(swUrl);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the old content will have been purged and\r\n              // the fresh content will have been added to the cache.\r\n              // It's the perfect time to display a \"New content is\r\n              // available; please refresh.\" message in your web app.\r\n              console.log('New content is available; please refresh.');\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      if (\r\n        response.status === 404 ||\r\n        response.headers.get('content-type').indexOf('javascript') === -1\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from \"react\"\r\n\r\n/**\r\n * Adjusts the text that displays for the playtime based on the\r\n * playtime passed to it. i.e. hours/Hour minutes/minute\r\n *\r\n * @param {this.props} {playTimeMinutes}\r\n * @returns\r\n */\r\nconst PlayTime = ({ playTimeMinutes }) => {\r\n  const hours = Math.floor(playTimeMinutes / 60)\r\n  const minutes = Math.floor(playTimeMinutes % 60)\r\n  const hourText = hours === 1 ? \"Hour\" : \"Hours\"\r\n  const minuteText = minutes === 1 ? \"Minute\" : \"Minutes\"\r\n  return (\r\n    <h3>\r\n      {hours !== 0 ? `${hours} ${hourText}` : null}\r\n      {hours !== 0 && minutes !== 0 ? ` and ` : null}\r\n      {minutes !== 0 ? `${minutes} ${minuteText}` : null}\r\n      {playTimeMinutes !== 0 ? \" Played\" : \"No Play Time\"}\r\n    </h3>\r\n  )\r\n}\r\n/**\r\n * Generates buttons for paging though content based on the props passed in\r\n *\r\n * @param {this.props} {previousPageFn, nextPageFn, currentPage, totalPages}\r\n */\r\nconst PaginationButtons = ({\r\n  previousPageFn,\r\n  nextPageFn,\r\n  currentPage,\r\n  totalPages\r\n}) => {\r\n  let buttonsStatus = { next: false, previous: false }\r\n  if (totalPages === currentPage) {\r\n    buttonsStatus.next = true\r\n  }\r\n  if (currentPage === 1) {\r\n    buttonsStatus.previous = true\r\n  }\r\n  return (\r\n    <div className=\"steam-games__pagination-buttons\">\r\n      <p>\r\n        <strong>\r\n          Current page is: {currentPage} out of{\" \"}\r\n          {totalPages !== 0 ? totalPages : 1}\r\n        </strong>\r\n      </p>\r\n      <div>\r\n        <button\r\n          onClick={previousPageFn}\r\n          data-total-pages={totalPages}\r\n          disabled={buttonsStatus.previous}\r\n        >\r\n          Previous Page\r\n        </button>\r\n        <button\r\n          onClick={nextPageFn}\r\n          data-total-pages={totalPages}\r\n          disabled={buttonsStatus.next}\r\n        >\r\n          Next Page\r\n        </button>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\n/**\r\n * Generates a list of games\r\n *\r\n * @param {Array} gamesList steamGamesList\r\n * @param {String} imgPath\r\n * @param {String} imgType\r\n */\r\nconst SteamGamesList = ({ gamesList, imgPath, imgType }) => (\r\n  <ul className=\"steam-games__games-list\">\r\n    {gamesList.map(({ appid, name, playtime_forever: playTime }) => (\r\n      <li key={appid}>\r\n        <h2>{name}</h2>\r\n        <img\r\n          src={`${imgPath}${appid}${imgType}`}\r\n          alt=\"\"\r\n          width=\"460\"\r\n          height=\"215\"\r\n        />\r\n        <PlayTime playTimeMinutes={playTime} />\r\n        <a\r\n          href={`https://store.steampowered.com/app/${appid}/`}\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          {`Check out ${name} on Steam`}\r\n        </a>\r\n      </li>\r\n    ))}\r\n  </ul>\r\n)\r\n\r\n/**\r\n * Displays checkboxes on the page for each item in the filterList\r\n * provided\r\n *\r\n * @param {this.props object} {filterList, onChangeFn}\r\n * @returns\r\n */\r\nconst FilterCheckboxes = ({ filterList, onChangeFn }) => {\r\n  return (\r\n    <React.Fragment>\r\n      {filterList.length !== 0 ? (\r\n        <ul>\r\n          {filterList.map(\r\n            (\r\n              { start, end, isChecked, isUnplayed, filteredGameCount },\r\n              index\r\n            ) => {\r\n              const key = `${start + end}-${index}`\r\n              const startHours = Math.round(start / 60)\r\n              const endHours = Math.round(end / 60)\r\n              let labelText = `${startHours} to ${endHours} hours (${filteredGameCount})`\r\n              if (isUnplayed) {\r\n                labelText = `Unplayed Games (${filteredGameCount})`\r\n              } else if (end === 0) {\r\n                labelText = `${startHours} to less than 1 hour (${filteredGameCount})`\r\n              }\r\n              return (\r\n                <li key={key}>\r\n                  <label htmlFor={key}>{labelText}</label>\r\n                  <input\r\n                    id={key}\r\n                    type=\"checkbox\"\r\n                    onChange={onChangeFn}\r\n                    data-index={index}\r\n                    checked={isChecked}\r\n                  />\r\n                </li>\r\n              )\r\n            }\r\n          )}\r\n        </ul>\r\n      ) : null}\r\n    </React.Fragment>\r\n  )\r\n}\r\n\r\n/**\r\n * JSX for ordering radio buttons\r\n *\r\n * @param {function} { onChangeFn }\r\n */\r\nconst OrderRadioButtons = ({ onChangeFn }) => (\r\n  <div className=\"steam-games__order-list\">\r\n    <div>\r\n      <label htmlFor=\"order-most-time\">Order by Most Played</label>\r\n      <input\r\n        type=\"radio\"\r\n        name=\"order\"\r\n        value=\"most-time\"\r\n        id=\"order-most-time\"\r\n        onChange={onChangeFn}\r\n      />\r\n    </div>\r\n    <div>\r\n      <label htmlFor=\"order-least-time\">Order by Least Played</label>\r\n      <input\r\n        type=\"radio\"\r\n        name=\"order\"\r\n        value=\"least-time\"\r\n        id=\"order-least-time\"\r\n        onChange={onChangeFn}\r\n      />\r\n    </div>\r\n    <div>\r\n      <label htmlFor=\"order-alphabetical\">Order Alphabetically</label>\r\n      <input\r\n        name=\"order\"\r\n        type=\"radio\"\r\n        value=\"alphabetical\"\r\n        id=\"order-alphabetical\"\r\n        onChange={onChangeFn}\r\n      />\r\n    </div>\r\n    <div>\r\n      <label htmlFor=\"order-default\">No Order</label>\r\n      <input\r\n        name=\"order\"\r\n        type=\"radio\"\r\n        value=\"default\"\r\n        id=\"order-default\"\r\n        onChange={onChangeFn}\r\n      />\r\n    </div>\r\n  </div>\r\n)\r\n/**\r\n * All options and the filtering menu\r\n *\r\n * @param {*} {\r\n *   collapsedData,\r\n *   totalGames,\r\n *   filteredGamesCount,\r\n *   playtimeFilters,\r\n *   toggleFiltersFn,\r\n *   updatePlaytimeFilterFn,\r\n *   updateSearchTextFn,\r\n *   updateOrderFn\r\n * }\r\n */\r\nconst FilterMenu = ({\r\n  collapsedData,\r\n  totalGames,\r\n  filteredGamesCount,\r\n  playtimeFilters,\r\n  toggleFiltersFn,\r\n  updatePlaytimeFilterFn,\r\n  updateSearchTextFn,\r\n  updateOrderFn\r\n}) => (\r\n  <React.Fragment>\r\n    <div className=\"steam-games__filter-header\">\r\n      <h2 id=\"steamGamesFilterList\">Filter Group</h2>\r\n      <button onClick={toggleFiltersFn}>{collapsedData.buttonText}</button>\r\n    </div>\r\n    <div\r\n      className={`steam-games__filter-options ${\r\n        collapsedData.filterOptionsClass\r\n      }`}\r\n      role=\"group\"\r\n      aria-labelledby=\"steamGamesFilterList\"\r\n    >\r\n      <h3>\r\n        Displaying {totalGames} Out of {filteredGamesCount} Games\r\n      </h3>\r\n      <FilterCheckboxes\r\n        filterList={playtimeFilters}\r\n        onChangeFn={updatePlaytimeFilterFn}\r\n      />\r\n      <div className=\"steam-games__filter-search\">\r\n        <label htmlFor=\"gamesSearchBox\">Search Games</label>\r\n        <input id=\"gamesSearchBox\" type=\"text\" onChange={updateSearchTextFn} />\r\n      </div>\r\n      <OrderRadioButtons onChangeFn={updateOrderFn} />\r\n    </div>\r\n  </React.Fragment>\r\n)\r\n\r\nexport { PaginationButtons, SteamGamesList, FilterMenu }\r\n","import React, { Component } from \"react\"\r\nimport {\r\n  PaginationButtons,\r\n  SteamGamesList,\r\n  FilterMenu\r\n} from \"./SteamGamesExtraComponents\"\r\nimport \"./SteamGames.css\"\r\nclass SteamGames extends Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.state = {\r\n      gamesLoaded: false,\r\n      gamesList: [],\r\n      totalGames: 0,\r\n      filteredTotalGames: 0,\r\n      currentPage: 1,\r\n      playtimeFilters: [],\r\n      searchFilter: \"\",\r\n      orderType: \"\",\r\n      collapseFilters: true\r\n    }\r\n  }\r\n\r\n  //============================================\r\n  //===================Events===================\r\n  //============================================\r\n\r\n  /**\r\n   * Updates the current page, insuring it doesn't go past\r\n   * the totalPages currently being shown.\r\n   *\r\n   * @memberof SteamGames\r\n   */\r\n  nextPage = event => {\r\n    const totalPages = event.currentTarget.dataset.totalPages\r\n    this.setState(prevState => {\r\n      let newState = { ...prevState }\r\n      if (prevState.currentPage > totalPages) {\r\n        newState.currentPage = totalPages\r\n      } else {\r\n        newState.currentPage = prevState.currentPage + 1\r\n      }\r\n      return newState\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Updates the current page, insuring it doesn't go below\r\n   * the totalPages currently being shown.\r\n   *\r\n   * @memberof SteamGames\r\n   */\r\n  previousPage = event => {\r\n    const totalPages = event.currentTarget.dataset.totalPages\r\n\r\n    this.setState(prevState => {\r\n      let newState = { ...prevState }\r\n      if (prevState.currentPage > totalPages) {\r\n        newState.currentPage = totalPages - 1\r\n      } else if (newState.currentPage !== 0) {\r\n        newState.currentPage = prevState.currentPage - 1\r\n      } else {\r\n        newState.currentPage = prevState.currentPage\r\n      }\r\n      return newState\r\n    })\r\n  }\r\n  /**\r\n   * Updates the checked state of the pressed playtime filter option\r\n   *\r\n   * @memberof SteamGames\r\n   */\r\n  updatePlaytimeFilter = event => {\r\n    const { index } = event.currentTarget.dataset\r\n    this.setState(prevState => {\r\n      let newState = { ...prevState }\r\n      newState.playtimeFilters[index].isChecked = !prevState.playtimeFilters[\r\n        index\r\n      ].isChecked\r\n\r\n      return newState\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Updates state with the text from the search filter\r\n   *\r\n   * @memberof SteamGames\r\n   */\r\n  updateSearchText = event => {\r\n    const searchInput = event.currentTarget.value\r\n    this.setState({ searchFilter: searchInput })\r\n  }\r\n\r\n  /**\r\n   * Updates the filtered games array order based on the order type selected\r\n   *\r\n   * @memberof SteamGames\r\n   */\r\n  updateOrder = event => {\r\n    this.setState({ orderType: event.currentTarget.value })\r\n  }\r\n\r\n  /**\r\n   * Toggles the display state of the filter menu\r\n   *\r\n   * @memberof SteamGames\r\n   */\r\n  toggleFilters = () => {\r\n    this.setState(prevState => {\r\n      let newState = { ...prevState }\r\n      newState.collapseFilters = !prevState.collapseFilters\r\n      return newState\r\n    })\r\n  }\r\n  //============================================\r\n  //==============Logic Functions===============\r\n  //============================================\r\n\r\n  /**\r\n   * Created a function generated from this.state.playtimeFilters data.\r\n   * The returned function can be passed an {int} compareValue that checks if the compareValue\r\n   * is in range\r\n   *\r\n   * @param {int} start of the range\r\n   * @param {int} end of the range\r\n   * @param {Boolean} isUnplayed\r\n   * @memberof SteamGames\r\n   * @returns {Function} Function that determines if the passed value is in range\r\n   */\r\n  playtimeRangeCheck = (start, end, isUnplayed) => compareValue => {\r\n    let valueInRange = false\r\n    if (\r\n      (compareValue <= start && compareValue > end) ||\r\n      (isUnplayed === true && compareValue === 0)\r\n    ) {\r\n      valueInRange = true\r\n    }\r\n    return valueInRange\r\n  }\r\n\r\n  /**\r\n   * Takes in a game list, and applies the selected playtimeFilters to the passed games list.\r\n   *\r\n   * @param {Array} gamesList Array of games\r\n   * @memberof SteamGames\r\n   * @returns {Array} Filtered Games list\r\n   */\r\n  filterPlaytimes(gamesList, playtimeFilters) {\r\n    const enabledPlaytimeFilters = playtimeFilters.filter(\r\n      ({ isChecked }) => !isChecked\r\n    )\r\n\r\n    const playtimeRangeValidationCheckers = enabledPlaytimeFilters.map(\r\n      ({ start, end, isUnplayed }) => {\r\n        return this.playtimeRangeCheck(start, end, isUnplayed)\r\n      }\r\n    )\r\n\r\n    //Filters out any games that fit the range found in the EnabledPlaytimeFilters\r\n    const filteredGames = gamesList.filter(({ playtime_forever }) => {\r\n      const inFilterRange = playtimeRangeValidationCheckers.some(\r\n        playtimeFilter => playtimeFilter(playtime_forever)\r\n      )\r\n      return !inFilterRange\r\n    })\r\n\r\n    return filteredGames\r\n  }\r\n\r\n  /**\r\n   * Returns an object of the min and max playtimes from the\r\n   * gamesList state\r\n   *\r\n   * @returns {Object} Min and Max playtime\r\n   */\r\n  getMinAndMaxPlaytime(gamesList) {\r\n    const maxMinutes = gamesList.reduce(\r\n      (highest, current) =>\r\n        highest > current.playtime_forever ? highest : current.playtime_forever\r\n    )\r\n    const minMinutes = gamesList.reduce(\r\n      (lowest, current) =>\r\n        lowest < current.playtime_forever ? lowest : current.playtime_forever\r\n    )\r\n\r\n    return { maxPlaytime: maxMinutes, minPlaytime: minMinutes }\r\n  }\r\n\r\n  /**\r\n   * Gets the current and total pages as an object\r\n   *\r\n   * @param {Array} gamesList\r\n   * @param {Int} currentPage\r\n   *\r\n   * @returns {Object} Current and Total Pages\r\n   */\r\n  getPaginationPages(gamesList) {\r\n    const { currentPage } = this.state\r\n    const { gamesPerPage } = this.props\r\n    const totalPages = Math.ceil(gamesList.length / gamesPerPage)\r\n\r\n    return { currentPage, totalPages }\r\n  }\r\n\r\n  /**\r\n   * fetches the gameState from the gamesFetch\r\n   *\r\n   * @returns {Promise} Promise that returns new state to be used\r\n   * @memberof SteamGames\r\n   */\r\n  fetchGameState() {\r\n    const { gamesFetchUrl } = this.props\r\n\r\n    const promise = new Promise(resolve => {\r\n      fetch(gamesFetchUrl)\r\n        .then(response => response.json())\r\n        .then(({ response: { game_count: gamesCount, games } }) => {\r\n          resolve({\r\n            gamesLoaded: true,\r\n            gamesList: games,\r\n            totalGames: gamesCount\r\n          })\r\n        })\r\n    })\r\n\r\n    return promise\r\n  }\r\n\r\n  /**\r\n   * Generates the state used for displaying the playTime checkboxes.\r\n   *\r\n   * Returns a promise so it can be chained to set state at a later point\r\n   *\r\n   * @param {Object} newState\r\n   * @returns Promise which passes the newState object\r\n   * @memberof SteamGames\r\n   */\r\n  generatePlaytimeFiltersToState(newState) {\r\n    const promise = new Promise(resolve => {\r\n      const { checkboxes, filterUnplayed } = this.props.hoursFilterRange\r\n      const { gamesList } = newState\r\n      const { maxPlaytime, minPlaytime } = this.getMinAndMaxPlaytime(gamesList)\r\n      const playtimeRange = Math.round((maxPlaytime - minPlaytime) / checkboxes)\r\n      let playtimeFilters = []\r\n\r\n      for (let count = 1; count <= checkboxes; count++) {\r\n        let end = maxPlaytime - playtimeRange * count\r\n        let start = end + playtimeRange\r\n        end = end <= 0 ? 0 : end\r\n        playtimeFilters.push({ start, end, isChecked: true, isUnplayed: false })\r\n      }\r\n      //if the prop for filtering out unplayed games has been set, push an extra\r\n      //item into the array to generate an extra checkbox\r\n      if (filterUnplayed) {\r\n        playtimeFilters.push({\r\n          start: 0,\r\n          end: 0,\r\n          isChecked: true,\r\n          isUnplayed: true\r\n        })\r\n      }\r\n\r\n      const filterCountWithGameCounts = playtimeFilters.map(filterObject => {\r\n        const { start, end, isUnplayed } = filterObject\r\n        const newFilterObject = { ...filterObject }\r\n        const filteredArray = gamesList.filter(({ playtime_forever }) =>\r\n          this.playtimeRangeCheck(start, end, isUnplayed)(playtime_forever)\r\n        )\r\n        newFilterObject.filteredGameCount = filteredArray.length\r\n        return newFilterObject\r\n      })\r\n      newState.playtimeFilters = filterCountWithGameCounts\r\n      resolve(newState)\r\n    })\r\n\r\n    return promise\r\n  }\r\n\r\n  /**\r\n   * Pagination passed array and returns the current current states page\r\n   * and the prop amount of pages\r\n   *\r\n   * @param {Array} gamesList\r\n   * @param {Int} currentPage\r\n   */\r\n  getCurrentGamesForPage(gamesList, currentPage) {\r\n    const { gamesPerPage } = this.props\r\n    const startIndex = currentPage * gamesPerPage - gamesPerPage\r\n    const finishIndex = currentPage * gamesPerPage\r\n    const gamesForPage = gamesList.slice(startIndex, finishIndex)\r\n\r\n    return gamesForPage\r\n  }\r\n  /**\r\n   * Takes a passed games list and returns a reorder version of that list\r\n   * based on the this.state.orderType\r\n   *\r\n   * @param {Array} gamesList\r\n   * @returns {Array} Ordered games list\r\n   * @memberof SteamGames\r\n   */\r\n  orderGamesList(gamesList) {\r\n    const { orderType } = this.state\r\n    let reorderedGamesList = [...gamesList]\r\n\r\n    const sortCompareFunction = isAscending => {\r\n      const ascendingCompare = (a, b) => {\r\n        if (a > b) {\r\n          return -1\r\n        } else if (a < b) {\r\n          return 1\r\n        }\r\n        return 0\r\n      }\r\n      const descendingCompare = (a, b) => {\r\n        if (a < b) {\r\n          return -1\r\n        } else if (a > b) {\r\n          return 1\r\n        }\r\n        return 0\r\n      }\r\n\r\n      return isAscending ? ascendingCompare : descendingCompare\r\n    }\r\n    switch (orderType) {\r\n      case \"most-time\":\r\n        reorderedGamesList.sort(\r\n          ({ playtime_forever: a }, { playtime_forever: b }) =>\r\n            sortCompareFunction(true)(a, b)\r\n        )\r\n        break\r\n      case \"least-time\":\r\n        reorderedGamesList.sort(\r\n          ({ playtime_forever: a }, { playtime_forever: b }) =>\r\n            sortCompareFunction(false)(a, b)\r\n        )\r\n        break\r\n      case \"alphabetical\":\r\n        reorderedGamesList.sort(({ name: a }, { name: b }) =>\r\n          sortCompareFunction(false)(a, b)\r\n        )\r\n        break\r\n\r\n      default:\r\n        reorderedGamesList = gamesList\r\n    }\r\n\r\n    return reorderedGamesList\r\n  }\r\n\r\n  /**\r\n   * Returns a filtered games list array based on the various filters\r\n   * that have been set in state.\r\n   *\r\n   * @returns {Array} Filtered list of games\r\n   * @memberof SteamGames\r\n   */\r\n  getFilteredGamesList() {\r\n    const { gamesList, playtimeFilters } = this.state\r\n    let filteredGamesList = [...gamesList]\r\n\r\n    filteredGamesList = this.filterPlaytimes(filteredGamesList, playtimeFilters)\r\n    filteredGamesList = this.filterSearchedGames(filteredGamesList)\r\n    filteredGamesList = this.orderGamesList(filteredGamesList)\r\n\r\n    return filteredGamesList\r\n  }\r\n\r\n  /**\r\n   * filters out the games that isn't in the search filter\r\n   *\r\n   * @param {Array} gamesList\r\n   * @returns {Array} Filtered list of games\r\n   * @memberof SteamGames\r\n   */\r\n  filterSearchedGames(gamesList) {\r\n    const { searchFilter } = this.state\r\n    let filteredGamesList = [...gamesList]\r\n    filteredGamesList = filteredGamesList.filter(game => {\r\n      return game.name.toLowerCase().includes(searchFilter.toLowerCase())\r\n    })\r\n\r\n    return filteredGamesList\r\n  }\r\n\r\n  /**\r\n   * Gets values that changes based on a boolean\r\n   *\r\n   * @param {Boolean} isCollapsed\r\n   * @returns {Object} Object of values used in JSX\r\n   * @memberof SteamGames\r\n   */\r\n  getJsxValuesForCollapsed(isCollapsed) {\r\n    let collapsedResults = {}\r\n\r\n    if (isCollapsed) {\r\n      collapsedResults.buttonText = \"+\"\r\n      collapsedResults.filterOptionsClass = \"hidden\"\r\n    } else {\r\n      collapsedResults.buttonText = \"â€“\"\r\n      collapsedResults.filterOptionsClass = \"\"\r\n    }\r\n\r\n    return collapsedResults\r\n  }\r\n\r\n  /**\r\n   * Gets all of the calculated values for the component render\r\n   *\r\n   * @returns {Object} Objects of all of the necessary values\r\n   * @memberof SteamGames\r\n   */\r\n  getValuesForRender() {\r\n    const filteredGameList = this.getFilteredGamesList()\r\n    const filteredGamesCount = filteredGameList.length\r\n    const {\r\n      currentPage: tempCurrentPage,\r\n      totalPages\r\n    } = this.getPaginationPages(filteredGameList)\r\n\r\n    const currentPage =\r\n      tempCurrentPage > totalPages ? totalPages : tempCurrentPage\r\n\r\n    const paginatedGamesList = this.getCurrentGamesForPage(\r\n      filteredGameList,\r\n      currentPage\r\n    )\r\n\r\n    const collapsedFilterData = this.getJsxValuesForCollapsed(\r\n      this.state.collapseFilters\r\n    )\r\n\r\n    return {\r\n      filteredGamesCount,\r\n      currentPage,\r\n      totalPages,\r\n      paginatedGamesList,\r\n      collapsedFilterData\r\n    }\r\n  }\r\n\r\n  //============================================\r\n  //=============React Life cycle===============\r\n  //============================================\r\n\r\n  componentDidMount() {\r\n    //Gets the game sate from fetch, and uses it to generate filters for state\r\n    //before setting it into state\r\n    this.fetchGameState()\r\n      .then(newState => this.generatePlaytimeFiltersToState(newState))\r\n      .then(newState => this.setState(newState))\r\n  }\r\n\r\n  render() {\r\n    const { totalGames, gamesLoaded, playtimeFilters } = this.state\r\n    const { steamImgPath, steamImgType } = this.props\r\n    const {\r\n      filteredGamesCount,\r\n      currentPage,\r\n      totalPages,\r\n      paginatedGamesList,\r\n      collapsedFilterData\r\n    } = this.getValuesForRender()\r\n\r\n    return (\r\n      <div className=\"steam-games__wrapper\">\r\n        {gamesLoaded ? (\r\n          <React.Fragment>\r\n            <div className=\"steam-games__title\">\r\n              <h1>Steam Games Filter</h1>\r\n            </div>\r\n            <FilterMenu\r\n              collapsedData={collapsedFilterData}\r\n              totalGames={totalGames}\r\n              filteredGamesCount={filteredGamesCount}\r\n              playtimeFilters={playtimeFilters}\r\n              toggleFiltersFn={this.toggleFilters}\r\n              updatePlaytimeFilterFn={this.updatePlaytimeFilter}\r\n              updateSearchTextFn={this.updateSearchText}\r\n              updateOrderFn={this.updateOrder}\r\n            />\r\n            <PaginationButtons\r\n              className=\"steam-games__pagination\"\r\n              previousPageFn={this.previousPage}\r\n              nextPageFn={this.nextPage}\r\n              currentPage={currentPage}\r\n              totalPages={totalPages}\r\n            />\r\n            <SteamGamesList\r\n              gamesList={paginatedGamesList}\r\n              imgPath={steamImgPath}\r\n              imgType={steamImgType}\r\n            />\r\n            <PaginationButtons\r\n              className=\"steam-games__pagination\"\r\n              previousPageFn={this.previousPage}\r\n              nextPageFn={this.nextPage}\r\n              currentPage={currentPage}\r\n              totalPages={totalPages}\r\n            />\r\n          </React.Fragment>\r\n        ) : null}\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nSteamGames.defaultProps = {\r\n  steamImgPath: \"https://steamcdn-a.akamaihd.net/steam/apps/\",\r\n  steamImgType: \"/header.jpg\",\r\n  gamesPerPage: 3,\r\n  hoursFilterRange: { checkboxes: 3, filterUnplayed: true }\r\n}\r\n\r\nexport default SteamGames\r\n","import React from \"react\"\r\nimport ReactDOM from \"react-dom\"\r\nimport registerServiceWorker from \"./registerServiceWorker\"\r\nimport \"./index.css\"\r\n\r\nimport SteamGames from \"./components/SteamGames/SteamGames\"\r\n\r\nReactDOM.render(\r\n  <SteamGames gamesFetchUrl=\"./data/steam-games-with-names.json\" />,\r\n  document.getElementById(\"root\")\r\n)\r\nregisterServiceWorker()\r\n"],"sourceRoot":""}